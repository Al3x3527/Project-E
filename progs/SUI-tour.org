#+title: Sui Tour
* progs.src
this file contains three `#pragma sourcefile` tokens, pointing to `cl_progs.src`, `sv_progs.src`, and `m_progs.src`. This is a new type progs.src file, which is interpreted as Quake C.
* cl_progs.src
this file starts with a destination, `../csprogs.dat`, and lists 8 Quake C source files. This is an old type progs.src file, so each token after the first is interpreted as being a `#include` token.
* cl_defs.qc
this is the first file included in `cl_progs.src`. according to the header, this file was automatically generated by FTE. it appears that the compiler uses this file to expose built-in definitions to the `csprogs.dat` program.
* sh_customdefs.qc
this is a short file, with a header which reads "shared definitions". it contains one `#define` token and one function, `precache_everything`, which precaches `demon/dland2.wav` and 'models/testplayer.iqm'.
** precache_everything
#+begin_src quakec
void() precache_everything =
{
	precache_sound("demon/dland2.wav");
	precache_model("models/testplayer.iqm");
};
#+end_src
`demon/dland2.wav` is a sound file specified within the Quake engine source code, which plays when two entities impact. `models/testplayer.iqm` appears to be a custom placeholder model for the player entity built into the FTEQW engine.
* cl_customdefs.qc
the header of `cl_customdefs.qc` reads "Various globals that are used in this FTEQW example are defined here, they are not used by the engine itself". SUI QC uses these globals to create an interactive example menu.
** readvector
`cl_customdefs.qc` defines one custom funtion, `readvector`.
#+begin_src quakec
vector() readvector =
{
	vector r = '0 0 0';
	r_x = readcoord();
	r_y = readcoord();
	r_z = readcoord();
	return r;
};
#+end_src
this function apparently calls on the built-in fuction `readcoord` three times and returns the result as a vector.
* sui_sys.qc
#+begin_src quakec
// Shpuld's Simple UI lib - sui
// Created 11/2018
//
// sui is a simple QuakeC UI lib for drawing and handling game interfaces.
// The API is made simple and easy to build upon, but cuts have been made
// to keep complexity low.
#+end_src
the point of an API is that you don't need to understand how it works. that being said, I have ventured to document the contents of this file.
** macros (lines 10-22)
the code starts with `#ifdef MENU`, which means `#if defined(MACRONAME)`.
#+begin_src quakec
const float IE_KEYDOWN = 0;	/* Specifies that a key was pressed. Second argument is the scan code. Third argument is the unicode (printable) char value. Fourth argument denotes which keyboard(or mouse, if its a mouse 'scan' key) the event came from. Note that some systems may completely separate scan codes and unicode values, with a 0 value for the unspecified argument. */
const float IE_KEYUP = 1;	/* Specifies that a key was released. Arguments are the same as IE_KEYDOWN. On some systems, this may be fired instantly after IE_KEYDOWN was fired. */
const float IE_MOUSEDELTA = 2;	/* Specifies that a mouse was moved (touch screens and tablets typically give IE_MOUSEABS events instead, use _windowed_mouse 0 to test code to cope with either). Second argument is the X displacement, third argument is the Y displacement. Fourth argument is which mouse or touch event triggered the event. */
const float IE_MOUSEABS = 3;	/* Specifies that a mouse cursor or touch event was moved to a specific location relative to the virtual screen space. Second argument is the new X position, third argument is the new Y position. Fourth argument is which mouse or touch event triggered the event. */
const float IE_ACCELEROMETER = 4;
const float IE_FOCUS = 5;	/* Specifies that input focus was given. parama says mouse focus, paramb says keyboard focus. If either are -1, then it is unchanged. */
const float IE_JOYAXIS = 6;	/* Specifies that what value a joystick/controller axis currently specifies. x=axis, y=value. Will be called multiple times, once for each axis of each active controller. */

#define printf(x, ...) print(sprintf(x, __VA_ARGS__))
#+end_src
these constant floats are apparently associated with the firing of `MENU` macro events, each with their own set of arguments.
** framing (lines 25-176)
the next block of code is associated with framing. the concept of a "frame" here appears to be analagus to that of Emacs.the IO related constantsthe IO related constants
*** SUI frame actions
the framing section starts by defining some things:
#+begin_src quakec
struct _frame_t {
	vector pos;
	vector size;
	vector align;
};
const float MAX_FRAMES = 64;
_frame_t _frames[MAX_FRAMES];
float _frame_index;

const float SUI_ALIGN_START = 0;
const float SUI_ALIGN_CENTER = 1;
const float SUI_ALIGN_END = 2;
#+end_src
I will just list the functions here: (lines 44-122)
#+begin_src quakec
void() sui_reset_align
void(float algin) sui_set_x_align
void(float align) sui_set_y_align
void(vector align) sui_set_align
void(__inout vector point) sui_transform_point
void(__inout vector point, vector size) sui_transform_box
vector() sui_current_frame_pos
vector() sui_current_frame_size
#+end_src
*** SUI frame clipping
more definitions mark the start of a frame clipping section.
#+begin_src quakec
float _sui_is_clipping;
vector _sui_clip_area_mins;
vector _sui_clip_area_maxs;
#+end_src
clipping functions: (lines 127-175)
#+begin_src quakec
void() sui_clip_to_frame
void() sui_reset_clip
float() sui_is_clipping
void(vector pos, vector size) sui_push_frame
void() sui_pop_frame
void() sui_reset_frame
#+end_src
** actions (lines 176-1010)
#+begin_src quakec
// interaction for sui elements, relies a lot on reading globals to see which
// element id is under cursor or held or whatever, not the most elegant
// solution but in this highly imperative world of QuakeC we can live with it
#+end_src
*** mouse element interactions
begins with definitions (lines 182-199)
#+begin_src quakec
float _holding_click;
vector _cursor_click;
vector _cursor_position;
vector _cursor_relative_click;
vector _cursor_relative_hover;
struct _action_element_t {
	vector pos;
	vector size;
	string id;
	float kb_nav_disabled;
	void(float index, vector click_ratios) action;
};
const float MAX_ACTION_ELEMENTS = 256;
_action_element_t _action_elements[MAX_ACTION_ELEMENTS];
float _action_elements_index;

float _cursor_is_mouse_active;
float _cursor_mouse_activate_accum;
#+end_src
funtions in (lines 203-223)
#+begin_src quakec
float(vector point, vector min, vector max) is_2dpoint_in_bounds
float(vector point, vector pos, vector size) is_2dpoint_in_bbox
void() _action_element_count_sanity
#+end_src
a new set of defintions begins related to mouse actions. (lines 225-236)
#+begin_src quakec
const float MAX_MOUSE_ACTIONS = 16;
string _hover_actions[MAX_MOUSE_ACTIONS];
string _click_actions[MAX_MOUSE_ACTIONS];
string _hold_actions[MAX_MOUSE_ACTIONS];
string _release_actions[MAX_MOUSE_ACTIONS];
string _last_clicked_actions[MAX_MOUSE_ACTIONS];

float _hover_action_count;
float _click_action_count;
float _hold_action_count;
float _release_action_count;
float _last_clicked_action_count;
#+end_src
functions in (lines 240-480)
#+begin_src quakec
void() sui_reset_actions
void() sui_reset_click =
float() sui_click_held = { return _holding_click; };
float(string id) sui_is_clicked =
float(string id) sui_click_index =
float(string id) sui_is_hovered =
float(string id) sui_hover_index =
float(string id) sui_is_held =
float(string id) sui_hold_index =
float(string id) sui_is_last_clicked =
float(string id) sui_last_clicked_index =
float(string id) sui_is_released =
float(string id) sui_release_index =
float(float num) mouse_action_sanity =
void() activate_mouse_cursor =
void() deactivate_mouse_cursor =
void(vector pos, float is_mouse = TRUE) _sui_mouse_move =
//this is a longer function.
float(float is_mouse = TRUE) _sui_mouse1_down =
//this is a longer function.
float(float is_mouse = TRUE) _sui_mouse1_up =
//this is a longer longer function
#+end_src
*** keyboard navigation
definitions apparently related to keyboard navigation (lines 482-488)
#+begin_src quakec
vector _sui_kb_move_dir;
float _sui_hijacked_dirs;
string _sui_default_kb_focus;
const float KB_DIR_UP = 1;
const float KB_DIR_DOWN = 2;
const float KB_DIR_LEFT = 4;
const float KB_DIR_RIGHT = 8;
#+end_src
funtions (lines 490-632)
#+begin_src quakec
void(float kb_dir) sui_hijack_kb_nav =
void(string id) sui_set_default_kb_focus =
float(vector dir) kb_dir_from_vec =
void() _retarget_kb_cursor =
void(vector dir) _cursor_kb_move =
//this is a longer function
void(vector pos, vector size, string id, void(float index, vector click_ratios) action, float is_kb_nav_disabled = FALSE) sui_action_element =
#+end_src
*** input related stuff
definitions (lines 637-648)
#+begin_src quakec
string _sui_binding_command;
string _sui_binding_command_name;

struct _input_t {
	float char;
	float scan;
};
const float MAX_INPUTS = 64;

_input_t _input_buffer[MAX_INPUTS];
float _input_index;
float _input_length;
#+end_src
functions (lines 652-725)
#+begin_src quakec
float(__inout float char, __inout float scan) sui_get_input =
void() sui_reread_input =
void() sui_clear_input =
vector(float scan) sui_input_dir =
float(float scan) sui_input_is_confirm =
float(float scan) sui_input_is_back =
float(float char, float scan) _sui_add_input =
#+end_src
*** keycode scanning
lines (725-842)
#+begin_src quakec
float _scan_listens[MAX_INPUTS];
float _scan_listen_count;
float(float keycode) sui_listen_scan =
float(string command) sui_listen_command =
float() sui_listen_up =
float() sui_listen_down =
float() sui_listen_left =
float() sui_listen_right =
float() sui_listen_confirm =
float() sui_listen_back =
void() sui_menu_nav =
float(float scanx, float chary) sui_block_all =
float(float scanx, float chary) sui_block_none =
float(float scanx, float chary) sui_block_menu_navigation =
float(float scanx, float chary) sui_block_listened =
#+end_src
*** text input
lines (845-907)
#+begin_src quakec
string() sui_listen_text_input =
void(float char, float scan, __inout string text, __inout float cursor) sui_handle_text_input =
void(float maxlen, __inout string text, __inout float cursor) sui_cap_input_length =
#+end_src
*** key bindings
lines (909-944)
#+begin_src quakec
void(string command) _sui_unbind =
void(float scan, string command) _sui_do_keybind =
void(string command, string command_name) sui_start_bind =
#+end_src
*** input events
lines (947-1004)
#+begin_src quakec
var float(float scanx, float chary) sui_block_input_fn = sui_block_listened;
// void(float evtype, float scanx, float chary, float devid) sui_input_event
//	 same args is CSQC_InputEvent.
//	 return value tells you if sui used the event or not, in case you want to
//	 not let engine handle it if it was used.
// Sets all the internal sui action stuff, call it in CSQC_InputEvent
float(float evtype, float scanx, float chary, float devid) sui_input_event =
#+end_src
** drawing (lines 1010-1312)
*** components
lines (1010-1235)
#+begin_src quakec
void(float width, float height) sui_begin =
void() sui_draw_bind_overlay;
void() sui_debug_draw_action_elements;
void() sui_end =
// Different draw components:
void(vector pos, vector size, vector color, float alpha, float flags) sui_fill =
void(vector pos, vector size, string pic, vector color, float alpha, float flags) sui_pic =
void(vector pos, vector size, float width, vector color, float alpha, float flags) sui_border_box =
void(vector pos, vector size, string text, vector color, float alpha, float flags) sui_text =
void(float index, vector click_ratios) sui_noop = {};
void(float value) sui_slider_noop = {};
float(string id, vector pos, vector size, vector minmaxsteps, float value, void(float value) action) sui_slidercontrol =
void(string id, vector pos, vector size, __inout string text, __inout float cursor) sui_text_input =
void(string id, vector size, vector contentsize, __inout vector offset, vector scrollbar_widths) sui_scrollbar =
void(string id, vector pos, vector size, vector contentsize, __inout vector offset, vector scrollbar_widths, float scroll_step = 22) sui_scroll_view_begin =
void() sui_scroll_view_end =
#+end_src
*** lists, end
(lines 1237-1312)
#+begin_src quakec
float _sui_list_item_height;
float _sui_list_first;
float _sui_list_last;
float _sui_list_pos;
int _sui_list_index;
void(string id, vector pos, vector size, vector itemsize, float numitems, __inout vector offset, vector scrollbar_widths) sui_list_view_begin =
float(__inout vector pos) sui_list_item =
void() sui_list_view_end =
string(string id, vector pos, vector size, string name, string command) sui_binder =
void() sui_draw_bind_overlay =
void() sui_debug_draw_action_elements =
// -------------------- END OF SUI SYSTEM STUFF --------------------
#+end_src
* cl_menu.qc
there's nothing here.
* cl_player.qc
this file contains one function
#+begin_src quakec
void() CSQC_Input_Frame =
{
	input_movevalues_x = bound(-350, input_movevalues_x, 350);
	input_movevalues_y = bound(-350, input_movevalues_y, 350);
	input_movevalues_z = bound(-350, input_movevalues_z, 350);
};
#+end_src
this appears to access the player's input move values each frame and bound the values between -350 and 350. `CSQC_Input_Frame` appears to be an entry point not documented in the "CSQC guide for idiots", called every frame with a user input.
* cl_hud.qc
this file is intentionally left empty.
* cl_main.qc
this file contains placeholder entry point functions
#+begin_src quakec
void() CSQC_Ent_Remove =
void() CSQC_Shutdown =
noref void(float apiver, string enginename, float enginever) CSQC_Init =
noref void() CSQC_WorldLoaded =
noref void(float isnew) CSQC_Ent_Update =
void(float width, float height, float menushown) CSQC_UpdateView =
float(string cmd) CSQC_ConsoleCommand =
float(float evtype, float scanx, float chary, float devid) CSQC_InputEvent =
void() CSQC_Parse_Event =
float(string key, string val) find_player_id =
void(string printmsg, float printlvl) CSQC_Parse_Print =
#+end_src
** CSQC_UpdateView
`CSQC_UpdateView` deserves special attention. it is the entry point function used in Spike's hello world tutorial.
#+begin_src quakec
// CALLED EVERY CLIENT RENDER FRAME
void(float width, float height, float menushown) CSQC_UpdateView =
{
	//clear and update our global screen resolution vars
	clearscene();
	g_width = width;
	g_height = height;


	//disable quake status bar and quake crosshair
	setproperty(VF_DRAWENGINESBAR, 0);
	setproperty(VF_DRAWCROSSHAIR, 0);

	campos = getproperty(VF_ORIGIN);
	camang = getproperty(VF_ANGLES);

	//autoadd entities received from servers for drawing
	addentities(MASK_ENGINE);

	//does what you think it does
	renderscene();

	/*
	sui_begin(g_width, g_height);

	// Insert your own sui code here even for CSQC
	// Make sure to uncomment sui_input_event as well.

	sui_menu_nav();

	sui_end();
	*/
};
#+end_src

* sv_progs.src
* sv_defs.qc
* sh_customdefs.qc
* sv_customdefs.qc
* sv_combat.qc
* sv_enemies.qc
* sv_triggers.qc
* sv_player.qc
* sv_main.qc
* m_progs.src
* m_defs.qc
* sui_sys.qc
* m_menu.qc
* m_main.qc
