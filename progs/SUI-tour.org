#+title: Sui Tour
* progs.src
this file contains three `#pragma sourcefile` tokens, pointing to `cl_progs.src`, `sv_progs.src`, and `m_progs.src`. This is a new type progs.src file, which is interpreted as Quake C.
* cl_progs.src
this file starts with a destination, `../csprogs.dat`, and lists 8 Quake C source files. This is an old type progs.src file, so each token after the first is interpreted as being a `#include` token.
* cl_defs.qc
this is the first file included in `cl_progs.src`. according to the header, this file was automatically generated by FTE. it appears that the compiler uses this file to expose built-in definitions to the `csprogs.dat` program.
* sh_customdefs.qc
this is a short file, with a header which reads "shared definitions". it contains one `#define` token and one function, `precache_everything`, which precaches `demon/dland2.wav` and 'models/testplayer.iqm'.
** precache_everything
#+begin_src quakec
void() precache_everything =
{
	precache_sound("demon/dland2.wav");
	precache_model("models/testplayer.iqm");
};
#+end_src
`demon/dland2.wav` is a sound file specified within the Quake engine source code, which plays when two entities impact. `models/testplayer.iqm` appears to be a custom placeholder model for the player entity built into the FTEQW engine.
* cl_customdefs.qc
the header of `cl_customdefs.qc` reads "Various globals that are used in this FTEQW example are defined here, they are not used by the engine itself". SUI QC uses these globals to create an interactive example menu.
** readvector
`cl_customdefs.qc` defines one custom funtion, `readvector`.
#+begin_src quakec
vector() readvector =
{
	vector r = '0 0 0';
	r_x = readcoord();
	r_y = readcoord();
	r_z = readcoord();
	return r;
};
#+end_src
this function apparently calls on the built-in fuction `readcoord` three times and returns the result as a vector.
* sui_sys.qc
#+begin_src quakec
// Shpuld's Simple UI lib - sui
// Created 11/2018
//
// sui is a simple QuakeC UI lib for drawing and handling game interfaces.
// The API is made simple and easy to build upon, but cuts have been made
// to keep complexity low.
#+end_src
the point of an API is that you don't need to understand how it works. that being said, I have ventured to document the contents of this file.
** macros (lines 10-22)
the code starts with `#ifdef MENU`, which means `#if defined(MACRONAME)`.
#+begin_src quakec
const float IE_KEYDOWN = 0;	/* Specifies that a key was pressed. Second argument is the scan code. Third argument is the unicode (printable) char value. Fourth argument denotes which keyboard(or mouse, if its a mouse 'scan' key) the event came from. Note that some systems may completely separate scan codes and unicode values, with a 0 value for the unspecified argument. */
const float IE_KEYUP = 1;	/* Specifies that a key was released. Arguments are the same as IE_KEYDOWN. On some systems, this may be fired instantly after IE_KEYDOWN was fired. */
const float IE_MOUSEDELTA = 2;	/* Specifies that a mouse was moved (touch screens and tablets typically give IE_MOUSEABS events instead, use _windowed_mouse 0 to test code to cope with either). Second argument is the X displacement, third argument is the Y displacement. Fourth argument is which mouse or touch event triggered the event. */
const float IE_MOUSEABS = 3;	/* Specifies that a mouse cursor or touch event was moved to a specific location relative to the virtual screen space. Second argument is the new X position, third argument is the new Y position. Fourth argument is which mouse or touch event triggered the event. */
const float IE_ACCELEROMETER = 4;
const float IE_FOCUS = 5;	/* Specifies that input focus was given. parama says mouse focus, paramb says keyboard focus. If either are -1, then it is unchanged. */
const float IE_JOYAXIS = 6;	/* Specifies that what value a joystick/controller axis currently specifies. x=axis, y=value. Will be called multiple times, once for each axis of each active controller. */

#define printf(x, ...) print(sprintf(x, __VA_ARGS__))
#+end_src
these constant floats are apparently associated with the firing of `MENU` macro events, each with their own set of arguments.
** framing (lines 25-176)
the next block of code is associated with framing. the concept of a "frame" here appears to be analagus to that of Emacs.the IO related constantsthe IO related constants
*** SUI frame actions
the framing section starts by defining some things:
#+begin_src quakec
struct _frame_t {
	vector pos;
	vector size;
	vector align;
};
const float MAX_FRAMES = 64;
_frame_t _frames[MAX_FRAMES];
float _frame_index;

const float SUI_ALIGN_START = 0;
const float SUI_ALIGN_CENTER = 1;
const float SUI_ALIGN_END = 2;
#+end_src
I will just list the functions here: (lines 44-122)
#+begin_src quakec
void() sui_reset_align
void(float algin) sui_set_x_align
void(float align) sui_set_y_align
void(vector align) sui_set_align
void(__inout vector point) sui_transform_point
void(__inout vector point, vector size) sui_transform_box
vector() sui_current_frame_pos
vector() sui_current_frame_size
#+end_src
*** SUI frame clipping
more definitions mark the start of a frame clipping section.
#+begin_src quakec
float _sui_is_clipping;
vector _sui_clip_area_mins;
vector _sui_clip_area_maxs;
#+end_src
clipping functions: (lines 127-175)
#+begin_src quakec
void() sui_clip_to_frame
void() sui_reset_clip
float() sui_is_clipping
void(vector pos, vector size) sui_push_frame
void() sui_pop_frame
void() sui_reset_frame
#+end_src
** actions (lines 176-1010)
#+begin_src quakec
// interaction for sui elements, relies a lot on reading globals to see which
// element id is under cursor or held or whatever, not the most elegant
// solution but in this highly imperative world of QuakeC we can live with it
#+end_src
*** mouse element interactions
begins with definitions (lines 182-199)
#+begin_src quakec
float _holding_click;
vector _cursor_click;
vector _cursor_position;
vector _cursor_relative_click;
vector _cursor_relative_hover;
struct _action_element_t {
	vector pos;
	vector size;
	string id;
	float kb_nav_disabled;
	void(float index, vector click_ratios) action;
};
const float MAX_ACTION_ELEMENTS = 256;
_action_element_t _action_elements[MAX_ACTION_ELEMENTS];
float _action_elements_index;

float _cursor_is_mouse_active;
float _cursor_mouse_activate_accum;
#+end_src
funtions in (lines 203-223)
#+begin_src quakec
float(vector point, vector min, vector max) is_2dpoint_in_bounds
float(vector point, vector pos, vector size) is_2dpoint_in_bbox
void() _action_element_count_sanity
#+end_src
a new set of defintions begins related to mouse actions. (lines 225-236)
#+begin_src quakec
const float MAX_MOUSE_ACTIONS = 16;
string _hover_actions[MAX_MOUSE_ACTIONS];
string _click_actions[MAX_MOUSE_ACTIONS];
string _hold_actions[MAX_MOUSE_ACTIONS];
string _release_actions[MAX_MOUSE_ACTIONS];
string _last_clicked_actions[MAX_MOUSE_ACTIONS];

float _hover_action_count;
float _click_action_count;
float _hold_action_count;
float _release_action_count;
float _last_clicked_action_count;
#+end_src
functions in (lines 240-480)
#+begin_src quakec
void() sui_reset_actions
void() sui_reset_click =
float() sui_click_held = { return _holding_click; };
float(string id) sui_is_clicked =
float(string id) sui_click_index =
float(string id) sui_is_hovered =
float(string id) sui_hover_index =
float(string id) sui_is_held =
float(string id) sui_hold_index =
float(string id) sui_is_last_clicked =
float(string id) sui_last_clicked_index =
float(string id) sui_is_released =
float(string id) sui_release_index =
float(float num) mouse_action_sanity =
void() activate_mouse_cursor =
void() deactivate_mouse_cursor =
void(vector pos, float is_mouse = TRUE) _sui_mouse_move =
//this is a longer function.
float(float is_mouse = TRUE) _sui_mouse1_down =
//this is a longer function.
float(float is_mouse = TRUE) _sui_mouse1_up =
//this is a longer longer function
#+end_src
*** keyboard navigation
definitions apparently related to keyboard navigation (lines 482-488)
#+begin_src quakec
vector _sui_kb_move_dir;
float _sui_hijacked_dirs;
string _sui_default_kb_focus;
const float KB_DIR_UP = 1;
const float KB_DIR_DOWN = 2;
const float KB_DIR_LEFT = 4;
const float KB_DIR_RIGHT = 8;
#+end_src
funtions (lines 490-632)
#+begin_src quakec
void(float kb_dir) sui_hijack_kb_nav =
void(string id) sui_set_default_kb_focus =
float(vector dir) kb_dir_from_vec =
void() _retarget_kb_cursor =
void(vector dir) _cursor_kb_move =
//this is a longer function
void(vector pos, vector size, string id, void(float index, vector click_ratios) action, float is_kb_nav_disabled = FALSE) sui_action_element =
#+end_src
*** input related stuff
definitions (lines 637-648)
#+begin_src quakec
string _sui_binding_command;
string _sui_binding_command_name;

struct _input_t {
	float char;
	float scan;
};
const float MAX_INPUTS = 64;

_input_t _input_buffer[MAX_INPUTS];
float _input_index;
float _input_length;
#+end_src
functions (lines 652-725)
#+begin_src quakec
float(__inout float char, __inout float scan) sui_get_input =
void() sui_reread_input =
void() sui_clear_input =
vector(float scan) sui_input_dir =
float(float scan) sui_input_is_confirm =
float(float scan) sui_input_is_back =
float(float char, float scan) _sui_add_input =
#+end_src
*** keycode scanning
lines (725-842)
#+begin_src quakec
float _scan_listens[MAX_INPUTS];
float _scan_listen_count;
float(float keycode) sui_listen_scan =
float(string command) sui_listen_command =
float() sui_listen_up =
float() sui_listen_down =
float() sui_listen_left =
float() sui_listen_right =
float() sui_listen_confirm =
float() sui_listen_back =
void() sui_menu_nav =
float(float scanx, float chary) sui_block_all =
float(float scanx, float chary) sui_block_none =
float(float scanx, float chary) sui_block_menu_navigation =
float(float scanx, float chary) sui_block_listened =
#+end_src
*** text input
lines (845-907)
#+begin_src quakec
string() sui_listen_text_input =
void(float char, float scan, __inout string text, __inout float cursor) sui_handle_text_input =
void(float maxlen, __inout string text, __inout float cursor) sui_cap_input_length =
#+end_src
*** key bindings
lines (909-944)
#+begin_src quakec
void(string command) _sui_unbind =
void(float scan, string command) _sui_do_keybind =
void(string command, string command_name) sui_start_bind =
#+end_src
*** input events
lines (947-1004)
#+begin_src quakec
var float(float scanx, float chary) sui_block_input_fn = sui_block_listened;
// void(float evtype, float scanx, float chary, float devid) sui_input_event
//	 same args is CSQC_InputEvent.
//	 return value tells you if sui used the event or not, in case you want to
//	 not let engine handle it if it was used.
// Sets all the internal sui action stuff, call it in CSQC_InputEvent
float(float evtype, float scanx, float chary, float devid) sui_input_event =
#+end_src
** drawing (lines 1010-1312)
*** components
lines (1010-1235)
#+begin_src quakec
void(float width, float height) sui_begin =
void() sui_draw_bind_overlay;
void() sui_debug_draw_action_elements;
void() sui_end =
// Different draw components:
void(vector pos, vector size, vector color, float alpha, float flags) sui_fill =
void(vector pos, vector size, string pic, vector color, float alpha, float flags) sui_pic =
void(vector pos, vector size, float width, vector color, float alpha, float flags) sui_border_box =
void(vector pos, vector size, string text, vector color, float alpha, float flags) sui_text =
void(float index, vector click_ratios) sui_noop = {};
void(float value) sui_slider_noop = {};
float(string id, vector pos, vector size, vector minmaxsteps, float value, void(float value) action) sui_slidercontrol =
void(string id, vector pos, vector size, __inout string text, __inout float cursor) sui_text_input =
void(string id, vector size, vector contentsize, __inout vector offset, vector scrollbar_widths) sui_scrollbar =
void(string id, vector pos, vector size, vector contentsize, __inout vector offset, vector scrollbar_widths, float scroll_step = 22) sui_scroll_view_begin =
void() sui_scroll_view_end =
#+end_src
*** lists, end
(lines 1237-1312)
#+begin_src quakec
float _sui_list_item_height;
float _sui_list_first;
float _sui_list_last;
float _sui_list_pos;
int _sui_list_index;
void(string id, vector pos, vector size, vector itemsize, float numitems, __inout vector offset, vector scrollbar_widths) sui_list_view_begin =
float(__inout vector pos) sui_list_item =
void() sui_list_view_end =
string(string id, vector pos, vector size, string name, string command) sui_binder =
void() sui_draw_bind_overlay =
void() sui_debug_draw_action_elements =
// -------------------- END OF SUI SYSTEM STUFF --------------------
#+end_src
* cl_menu.qc
there's nothing here.
* cl_player.qc
this file contains one function
#+begin_src quakec
void() CSQC_Input_Frame =
{
	input_movevalues_x = bound(-350, input_movevalues_x, 350);
	input_movevalues_y = bound(-350, input_movevalues_y, 350);
	input_movevalues_z = bound(-350, input_movevalues_z, 350);
};
#+end_src
this appears to access the player's input move values each frame and bound the values between -350 and 350. `CSQC_Input_Frame` appears to be an entry point not documented in the "CSQC guide for idiots", called every frame with a user input.
* cl_hud.qc
this file is intentionally left empty.
* cl_main.qc
this file contains placeholder entry point functions
#+begin_src quakec
void() CSQC_Ent_Remove =
void() CSQC_Shutdown =
noref void(float apiver, string enginename, float enginever) CSQC_Init =
noref void() CSQC_WorldLoaded =
noref void(float isnew) CSQC_Ent_Update =
void(float width, float height, float menushown) CSQC_UpdateView =
float(string cmd) CSQC_ConsoleCommand =
float(float evtype, float scanx, float chary, float devid) CSQC_InputEvent =
void() CSQC_Parse_Event =
float(string key, string val) find_player_id =
void(string printmsg, float printlvl) CSQC_Parse_Print =
#+end_src
** CSQC_UpdateView
`CSQC_UpdateView` deserves special attention. it is the entry point function used in Spike's hello world tutorial.
#+begin_src quakec
// CALLED EVERY CLIENT RENDER FRAME
void(float width, float height, float menushown) CSQC_UpdateView =
{
	//clear and update our global screen resolution vars
	clearscene();
	g_width = width;
	g_height = height;


	//disable quake status bar and quake crosshair
	setproperty(VF_DRAWENGINESBAR, 0);
	setproperty(VF_DRAWCROSSHAIR, 0);

	campos = getproperty(VF_ORIGIN);
	camang = getproperty(VF_ANGLES);

	//autoadd entities received from servers for drawing
	addentities(MASK_ENGINE);

	//does what you think it does
	renderscene();

	/*
	sui_begin(g_width, g_height);

	// Insert your own sui code here even for CSQC
	// Make sure to uncomment sui_input_event as well.

	sui_menu_nav();

	sui_end();
	*/
};
#+end_src

* sv_progs.src
this file is a second old style progs.dat file. it lists 8 Quake C source files which contribute to a `qwprogs.dat` program.
* sv_defs.qc
this file is a bit smaller than `cl_defs.qc`, but appears to have much the same contents and purpose, but for the `qwprogs.dat` program.
* sv_customdefs.qc
#+begin_src quakec
// put custom server-only globals and fields here

const float FL_JUMPRELEASED = 4096;
#+end_src
this file is for globals accessible only to the SSQC game. the first definition is the constant float `FL_JUMPRELEASED`, this is a vanilla constant that relates both to player physics and to player input.
** subs
#+begin_src quakec
void() sub_remove =
void() sub_noop = {};
#+end_src
these basic funtions are defined here in SUI QC instead of in `subs.qc`, a file that does not exist in this codebase.
** multicast
(lines 12-48)
#+begin_src quakec
void(float event) BeginEvent =
void(vector vec) MulticastVector =
void(float val) MulticastByte =
void(float val) MulticastShort =
void(float val) MulticastFloat =
void(entity e) MulticastEnt =
void(string s) MulticastString =
#+end_src
these are custom functions that make use of the `MSG_MULTICAST` built-in.
** light
this is a one line fuction that appears to remove light entities from the PVS. (line 50)
** linked lists
(lines 55-84)
#+begin_src quakec
entity player_chain_head;
.entity player_chain_next;
.entity player_chain_prev;
void(entity adding) player_chain_add =
void(entity removing) player_chain_remove =
#+end_src
the file ends with some definitions related to linked lists called "player chains".
* sv_combat.qc
there's nothing here.
* sv_enemies.qc
this file is intentionally left empty.
* sv_triggers.qc
this file contains an example trigger spawn function as a comment and two spawn functions.
#+begin_src quakec
void() info_null =
void() func_illusionary =
#+end_src
* sv_player.qc
#+begin_src quakec
//	Player.qc - Various stuff done for the player, including per-frame functions like PlayerPreThink and PlayerPostThink, also client specific stuff like PutClientInServer etc.
#+end_src
the first function defined in this file, `PlayerJump`, implements the `FL_JUMPRELEASED` constant defined in `sv_customdefs.qc`.
#+begin_src quakec
void() PlayerJump =
void() CheckImpulses =
vector() get_spawn_point =
void() PlayerPreThink =
void() PlayerPostThink =
void() ClientKill =
void() ClientConnect =
void() PlayerSpawn =
void() PutClientInServer =
void() ClientDisconnect =
void() SetNewParms =
void() SetChangeParms =
void() info_player_start =
#+end_src
the last functions have the prefix `SV`. these apparently have to do with console commands.
#+begin_src quakec
void(float elapsedtime) SV_PausedTic =
void(string command_string) SV_ParseClientCommand =
void() SV_RunClientCommand =
#+end_src
the names of the simple placeholder functions in this file largly describe their purpose.
* sv_main.qc
#+begin_src quakec
//	Main.qc - mostly functions that will be called from the engine and are expected to exist
//

void() main =
{
};

//called for each frame that QC runs
void() StartFrame =
{
};

void() worldspawn =
{
	precache_everything();
};

void() SpectatorConnect =
{
};
#+end_src
self explainatory.
* m_progs.src
the final old style progs.src file. it lists 4 files to be included in `menu.dat`.
* m_defs.qc
this def.qc file is smaller than the other two, but starts with the same header and macros. the numbers associated with each built-in function are different here from cl_defs or sv_defs. some functions are labeled as "Menuqc-specific version".
* m_menu.qc
this file apparently defines the content and behavior of the custom menu.
** style
the file starts by defining some global vector variables that have to do with the styling of the menu. (lines 1-13)
#+begin_src quakec
vector MENU_BG = '0.2 0.3 0.4';
vector MENU_BG_DARK = '0.1 0.15 0.2';
vector MENU_BORDER = '0.3 0.4 0.5';
vector MENU_BUTTON = '0.3 0.4 0.5';
vector MENU_BUTTON_BORDER = '0.35 0.45 0.55';
vector MENU_TEXT_1 = '1 1 1';
vector MENU_TEXT_2 = '0.7 0.75 0.75';
vector MENU_HIGHLIGHT = '1 1 1';
vector MENU_DARKEN = '1 1 1';

vector MENU_TEXT_SMALL = '8 8 0';
vector MENU_TEXT_MEDIUM = '16 16 0';
vector MENU_TEXT_LARGE = '24 24 0';
#+end_src
** input
the first two functions have to do with getting user input. (lines 15-64)
#+begin_src quakec
void() input_tester =
void(string id, vector pos, vector size, float maxlen, __inout string text, __inout float cursor) text_input_control =
#+end_src
** interactive
the  next functions have to do with interactive elements. (lines 66-110)
#+begin_src quakec
float(string id, vector pos, vector size, string text) my_button =
void(string id, vector pos, vector size, vector minmaxsteps, __inout float value) my_slider =
void(vector pos, vector size, vector minmaxsteps, string cvar_s, string name, string format) cvar_slider =
#+end_src
** binds
this part of the file defines a new struct `name_command` and a `name_command` `bindlist`, which holds some command bindings. (lines 112-134)
#+begin_src quakec
struct name_command {
	string name;
	string command;
};

name_command bindlist[] =
{
	{ "Forward", "+forward" },
	{ "Back", "+back" },
	{ "Left", "+moveleft" },
	{ "Right", "+moveright" },
	{ "Jump", "+jump" },
	{ "Jump1", "+jump" },
	{ "Jump2", "+jump" },
	{ "Jump3", "+jump" },
	{ "Jump4", "+jump" },
	{ "Jump5", "+jump" },
	{ "Jump6", "+jump" },
	{ "Jump7", "+jump" },
	{ "Jump8", "+jump" },
	{ "Jump9", "+jump" },
	{ "Jump0", "+jump" },
};
#+end_src
this is followed by a couple bind related functions. (lines 136-162)
#+begin_src quakec
void(string id, vector pos, vector size, string name, string command) bind_button =
void(string id, vector pos, vector size, __inout vector scrollofs) bind_list =
#+end_src
** menus
this part defines the actual content of menus. (lines 165-289)
#+begin_src quakec
float current_menu;
const float MENU_MAIN = 1;
const float MENU_SETTINGS = 2;
const float MENU_HELP = 3;

vector binds_scroll;
void() settings_menu =
void() help_menu =
void() main_menu =
void(vector size) root_menu =
#+end_src
end of file.
** main_menu
special attention to the main menu and how it was implemented. (lines 253-276)
*** Title Screen
#+begin_src quakec
void() main_menu =
{
	sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_START]);
	sui_text([0, 64], MENU_TEXT_LARGE, "Title Screen", [1, 1, 1], 1, 0);
#+end_src
the function starts with `sui_set_align`. this function is called 4 different times in `main_menu`, always taking the first vector argument: `SUI_ALIGN_CENTER` but switching between `SUI_ALIGN_START` and `SUI_ALIGN_END` for the second vector argument.
sui_set_align is defined in `sui_sys.qc`, where it stores the alignment of the frame `_frame_index` within the `_frames` `_frame_t` structure.
#+begin_src quakec
void(vector align) sui_set_align =
{
	_frames[_frame_index].align = align;
};
#+end_src
the frame index was set by `sui_pop_frame`, defined line 164 in `sui_sys.qc`. more on that later.
the alignments, `SUI_ALIGN_CENTER` and `SUI_ALIGN_START` apparently align the first element of the menu to the center and top of the frame.
`sui_text` defines the first element. this function is defined on line 1078 of `sui_sys.qc`.
#+begin_src quakec
void(vector pos, vector size, string text, vector color, float alpha, float flags) sui_text =
{
	sui_transform_box(pos, [stringwidth(text, 1, size), size_y]);

	drawstring(pos, text, size, color, alpha, flags);
};
#+end_src
it takes 6 arguments: vector pos, vector size, string text, vector color, float alpha, float flags. in this case, the position passed in is [0, 64]. `MENU_TEXT_LARGE` is the text size, defined on line 13 of `m_menu.qc`. "Title Screen" is the text content, [1, 1, 1] is the text color, 1 is the alpha, and 0 is passed in for flags.
*** Nav buttons
`m_menu.qc` lines 258-264
#+begin_src quakec
vector pos = [0, -24];
vector size = [120, 140];
sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_END]);
sui_push_frame(pos, size);

sui_fill([0, 0], size, MENU_BG, 0.3, 0);
sui_border_box([0, 0], size, 2, MENU_BORDER, 0.2, 0);
#+end_src
after creating the title text, a new frame is created. at position `pos` with size `size`. the alignment is set first, before a new frame is defined using `sui_push_frame`, defined on line 148 of `sui-sys.qc`.
why is `sui_set_align` called before `sui_push_frame`? it does not apply to the new frame.
#+begin_src quakec
void(vector pos, vector size) sui_push_frame =
{
	sui_transform_box(pos, size);

	_frame_index += 1;
	if (_frame_index >= MAX_FRAMES)
	{
		printf("^3sui warning: amount of frames = %.0f exceeds MAX_FRAMES = %.0f, consider increasing MAX_FRAMES\n", _frame_index, MAX_FRAMES);
		return;
	}

	_frames[_frame_index].pos = pos;
	_frames[_frame_index].size = size;
	_frames[_frame_index].align = [SUI_ALIGN_START, SUI_ALIGN_START]; // TODO allow customizing this
};
#+end_src
this defines a new frame at frame index += 1 from the previous frame, at position `pos` and with size `size` and alignment `SUI_ALIGN_START, SUI_ALIGN_START`.
`sui_fill` is defined on line 1049 of `sui_sys.qc`.
#+begin_src quakec
void(vector pos, vector size, vector color, float alpha, float flags) sui_fill =
{
	sui_transform_box(pos, size);

	drawfill(pos, size, color, alpha, flags);
};
#+end_src
`sui_border_box` is defined on line 1063.
#+begin_src quakec
void(vector pos, vector size, float width, vector color, float alpha, float flags) sui_border_box =
{
 sui_transform_box(pos, size);

	// Top line
	drawfill(pos, [size_x, width], color, alpha, flags);
	// Bottom line
	drawfill([pos_x, pos_y + size_y - width], [size_x, width], color, alpha, flags);
	// Left line
	drawfill([pos_x, pos_y + width], [width, size_y - width * 2], color, alpha, flags);
	// Right line
	drawfill([pos_x + size_x - width, pos_y + width], [width, size_y - width * 2], color, alpha, flags);
};
#+end_src
after creating a bordered and filled box of size `size` at position `pos`, we set the alignment of the frame to bottom center. (line 266)
#+begin_src quake c
sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_START]);
#+end_src
after settig the alignment again, 3 buttons are created. the alignment is set one more time before creating the final button. (lines 268-272)
#+begin_src quakec
my_button("mm_start", [0, 8], [size_x - 16, 20], "Start Game") ? localcmd("map test\n") : 0;
my_button("mm_settings", [0, 8 + 24], [size_x - 16, 20], "Settings") ? current_menu = MENU_SETTINGS : 0;
my_button("mm_help", [0, 8 + 48], [size_x - 16, 20], "Help") ? current_menu = MENU_HELP : 0;
sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_END]);
my_button("mm_quit", [0, -8], [size_x - 16, 20], "Quit") ? localcmd("quit\n") : 0;
#+end_src
the unusual syntax "function() ? somecode : 0" creates a menu element then defines an action associated with it. this appears to be equivalent to:
#+begin_example quakec
if(function()) {somecode;} : 0; //what does the : 0; do?
#+end_example
the function `my_button` is defined on line 66 of `m_menu.qc`.
#+begin_src quakec
float(string id, vector pos, vector size, string text) my_button =
{
  sui_push_frame(pos, size);
  vector basecolor = sui_is_hovered(id) ? MENU_BUTTON + MENU_HIGHLIGHT * 0.25 : MENU_BUTTON;
  basecolor = sui_is_held(id) ? MENU_BUTTON - MENU_DARKEN * 0.1 : basecolor;
  sui_fill([0, 0], size, basecolor, 0.6, 0);
  sui_border_box([0, 0], size, 1, MENU_BUTTON_BORDER, 0.4, 0);

  sui_set_align([SUI_ALIGN_CENTER, SUI_ALIGN_CENTER]);
  sui_text([0, 0], MENU_TEXT_SMALL, text, MENU_TEXT_1, 1, 0);
  sui_action_element([0, 0], size, id, sui_noop);
  sui_pop_frame();

  return sui_is_clicked(id);
};
#+end_src
this function starts by pushing a new frame for the new button. text within the button is aligned to center.
`sui_pop_frame` is called before returning the click status of the button.
*** end of function
the main menu function ends with: (lines 273-276)
#+begin_src quakec
	sui_pop_frame();

	sui_set_default_kb_focus("mm_start");
};
#+end_src
`sui_pop_frame` should not be confused with `sui_push_frame`. it is defined on line 164, and reverts the current frame index to the previous frame, `_frame_index -= 1`.
#+begin_src quakec
void() sui_pop_frame =
{
	if (_frame_index > 0) _frame_index -= 1;
};
#+end_src
`sui_set_default_kb_focus` is self explainatory.
* m_main.qc
this file defines some fundamental menu behaviors such as the initialization and drawing of the menu screen itself.
#+begin_src quakec
float menu_active;
float splash_time;
void() m_init =
vector() randomofs = { return [random() - 0.5, random() - 0.5] * 2; };
void(vector screensize) m_draw =
void() m_close =
void() m_open =
float(float evtype, float scanx, float chary, float devid) Menu_InputEvent =
float(string cmd) m_consolecommand =
void(float wantmode) m_toggle =
void() m_shutdown =
#+end_src
